import numpy as np
import matplotlib.pyplot as plt
from hcipy import *

from . import support_functions as sf
#import support_functions as sf

def get_aperture(aperturename=None, pupil_grid=None,
                 rotation_angle_aperture=0, oversampling_factor=8, rotation_primary_deg=0): #rotation_primary_deg=0
    """A helper function to return an aperture, and rotate it
    to the appropriate angle.

    Parameters
    ----------
    aperturename : string

    pupil_grid : the pupil grid (generated by make_pupil_grid in hcipy) on which
                 to generate the aperture

    rotation_angle_aperture : Boolean

    return_segments : Boolean

    #rotation_primary_deg : the rotation of the keck primary ralative to instrument in field tracking, in degrees
   

    Returns
    -------
    aperture, pupil_diameter : Field, float [units of meter]
    """


    if aperturename == 'open':
        aperture = evaluate_supersampled(make_circular_aperture(10.9), pupil_grid, 8)#2 * 5.573  #old one: 11.732

        pupil_diameter = 10.9 # meter

    elif aperturename == 'keck':

        aperture = evaluate_supersampled(make_keck_aperture(), pupil_grid, oversampling_factor)
        #aperture = sf.cen_rot(keck_aperture.shaped, rotation_primary_deg, pupil_grid.shape/2)
        

        pupil_diameter_long  = 10.92 # meter
        pupil_diameter_short = 9.92 # meter
        pupil_diameter = (pupil_diameter_long + pupil_diameter_short) / 2

    elif aperturename == 'NIRC2_large_hexagonal_mask':
        aperture = evaluate_supersampled(make_NIRC2_large_hexagonal_mask(), pupil_grid, oversampling_factor)

        pupil_diameter_long  = 10.68 # meter
        pupil_diameter_short = 9.7 # meter
        pupil_diameter = (pupil_diameter_long + pupil_diameter_short) / 2

    elif aperturename == 'NIRC2_incircle_mask':
        aperture = evaluate_supersampled(make_NIRC2_incircle_pupil_mask(), pupil_grid, oversampling_factor)

        pupil_diameter = 8.72 # meter

    elif aperturename == 'keck+NIRC2_large_hexagonal_mask':
        keck_aperture = evaluate_supersampled(make_keck_aperture(), pupil_grid, oversampling_factor)
        #keck_aperture = sf.cen_rot(keck_aperture.shaped, rotation_primary_deg, pupil_grid.shape/2)
        keck_aperture = Field(keck_aperture.ravel(), pupil_grid)

        large_hex_mask = evaluate_supersampled(make_NIRC2_large_hexagonal_mask(), pupil_grid, oversampling_factor)
        aperture = keck_aperture * large_hex_mask

        pupil_diameter_long  = 10.68 # meter
        pupil_diameter_short = 9.7 # meter
        pupil_diameter = (pupil_diameter_long + pupil_diameter_short) / 2

    elif aperturename == 'keck+NIRC2_incircle_mask':
        keck_aperture     = evaluate_supersampled(make_keck_aperture(), pupil_grid, oversampling_factor)
        #keck_aperture = sf.cen_rot(keck_aperture.shaped, rotation_primary_deg, pupil_grid.shape/2)
        keck_aperture = Field(keck_aperture.ravel(), pupil_grid)

        incircle_pup_mask = evaluate_supersampled(make_NIRC2_incircle_pupil_mask(), pupil_grid, oversampling_factor)
        aperture = keck_aperture * incircle_pup_mask

        pupil_diameter = 8.72 # meter

    elif aperturename == 'NIRC2_Lyot_Stop':
        aperture = evaluate_supersampled(make_NIRC2_lyot_stop(), pupil_grid, oversampling_factor)

        pupil_diameter_long  = 10.5 # meter
        pupil_diameter_short = 9.46 # meter
        pupil_diameter = (pupil_diameter_long + pupil_diameter_short) / 2

    elif aperturename == 'keck+NIRC2_Lyot_Stop':
        keck_aperture = evaluate_supersampled(make_keck_aperture(), pupil_grid, oversampling_factor)
        #keck_aperture = sf.cen_rot(keck_aperture.shaped, rotation_primary_deg, pupil_grid.shape/2)
        keck_aperture = Field(keck_aperture.ravel(), pupil_grid)

        lyot_stop     = evaluate_supersampled(make_NIRC2_lyot_stop(), pupil_grid, oversampling_factor)
        aperture      = keck_aperture * lyot_stop

        pupil_diameter_long  = 10.5 # meter
        pupil_diameter_short = 9.46
        pupil_diameter = (pupil_diameter_long + pupil_diameter_short) / 2
        
    elif aperturename == 'keck+OSIRIS_20_mas':
        keck_aperture = evaluate_supersampled(make_keck_aperture(), pupil_grid, oversampling_factor)
        #keck_aperture = sf.cen_rot(keck_aperture.shaped, rotation_primary_deg, pupil_grid.shape/2)
        keck_aperture = Field(keck_aperture.ravel(), pupil_grid)
        osi20 = evaluate_supersampled(circular_aperture(10.94), pupil_grid, oversampling_factor)
        aperture      = keck_aperture * osi20

        pupil_diameter_long  = 10.92 # meter
        pupil_diameter_short = 9.92 # meter
        pupil_diameter = (pupil_diameter_long + pupil_diameter_short) / 2
        
    elif aperturename == 'keck+OSIRIS_35_50_mas':
        keck_aperture = evaluate_supersampled(make_keck_aperture(), pupil_grid, oversampling_factor)
        #keck_aperture = sf.cen_rot(keck_aperture.shaped, rotation_primary_deg, pupil_grid.shape/2)
        keck_aperture = Field(keck_aperture.ravel(), pupil_grid)
        osi35 = evaluate_supersampled(circular_aperture(10.), pupil_grid, oversampling_factor)
        aperture      = keck_aperture * osi35

        pupil_diameter_long  = 10. # meter
        pupil_diameter_short = 9.92 # meter
        pupil_diameter = (pupil_diameter_long + pupil_diameter_short) / 2
  
    

    else:
        raise ValueError('No valid aperture chosen!')

    # rotating the aperture if necessary
    if np.abs(rotation_angle_aperture)>1e-6:
        # rotating the aperture about the center (pupil_grid.shape/2)
        aperture = sf.cen_rot(aperture.shaped, rotation_angle_aperture,
                              pupil_grid.shape/2)
        # making it a field again
        aperture = Field(aperture.ravel(), pupil_grid)

    return aperture, pupil_diameter

def make_keck_aperture(with_secondary=True, with_spiders=True, return_segments=False):
    ''' Generates the Keck aperture.

    Parameters
    ----------
    with_secondary : Boolean

    with_spiders : Boolean

    return_segments : Boolean

    Returns
    -------
    func : Field

    segments:

    '''
    # Keck II aperture

    #diameter of long side hexagonal element in meters
    D_subaperture_l = 1.8

    #diameter of short side hexagonal element in meters
    D_subaperture_s = D_subaperture_l * np.sqrt(3) / 2

    #mirror gap = 3 mm
    mirror_gap = 3e-3

    #Secondary diameter
    D_obscuration = 2.6 # meter

    D_spider = 25.4e-3 #spiders are 1 inch wide

    #Total mirror diameter
    D_tot = 7 * D_subaperture_s + 6 * mirror_gap

    #the edges of the mirror are non-reflective, removing 2mm, i.e. 4 mm from every diameter
    D_subaperture_l = 1.8 - 4e-3
    D_subaperture_s = D_subaperture_l * np.sqrt(3) / 2

    #Creating a hexagonal grid for adding the mirrors
    n_rings = 3
    circum_diameter = D_tot / (2 * n_rings + 1)
    segment_positions = make_hexagonal_grid(circum_diameter, n_rings, pointy_top=True)

    # removing the central segment
    segment_positions = segment_positions.subset(segment_positions.x**2 + segment_positions.y**2>0)

    #Creating mirror segments:
    segment = make_hexagonal_aperture(D_subaperture_l)

    #Adding mirror segments:
    if return_segments:
        segmented_aperture, segments = make_segmented_aperture(segment, segment_positions, return_segments=True)
    else:
        segmented_aperture = make_segmented_aperture(segment, segment_positions)

    #Adding Spiders
    spiders = 1
    spider_angles = np.linspace(0, 2*np.pi, 6, endpoint=False)+np.radians(30)

    secondary_obscuration = make_circular_aperture(D_obscuration)

    def func(grid):
        res = segmented_aperture(grid)

        if with_secondary:
            res *=  1 - secondary_obscuration(grid)

        if with_spiders:
            for angle in spider_angles:
                x = D_tot * np.cos(angle)
                y = D_tot * np.sin(angle)

                res *= Field(make_spider((0, 0), (x, y), D_spider)(grid),grid)

        return Field(res, grid)

    if return_segments:
        return func, segments
    else:
        return func

def make_NIRC2_large_hexagonal_mask():
    ''' Generates the NIRC2 large hexagonal mask

    not sure if this is correct
    source: KAON_1104_Vortex_User_Manual

    Parameters
    ----------

    Returns
    -------
    func : Field

    '''
    #diameter of long side hexagonal element in meters
    D_subaperture_l = 1.8

    #diameter of short side hexagonal element in meters
    D_subaperture_s = D_subaperture_l * np.sqrt(3) / 2

    #mirror gap = 3 mm
    mirror_gap = 3e-3

    #Secondary diameter
    D_secondary = 2.602 # meter

    D_spider = 44.49e-3 #spiders are 1 inch wide

    #Total mirror diameter
    D_tot = 10.656 # meter #7*D_subaperture_s+6*mirror_gap

    #the edges of the mirror are non-reflective, removing 2mm, i.e. 4 mm from every diameter
    D_subaperture_l = 1.8 - 4e-3
    D_subaperture_s = D_subaperture_l * np.sqrt(3) / 2

    #Creating a hexagonal grid for adding the mirrors
    n_rings = 3
    circum_diameter = D_tot / (2 * n_rings + 1)
    segment_positions = make_hexagonal_grid(circum_diameter, n_rings, pointy_top=True)

    # removing the central segment
    segment_positions = segment_positions.subset(segment_positions.x**2 + segment_positions.y**2>0)

    #Creating mirror segments:
    segment = make_hexagonal_aperture(D_subaperture_l)

    #Adding mirror segments:
    segmented_aperture = make_segmented_aperture(segment, segment_positions)

    #Adding Spiders
    spiders = 1
    spider_angles = np.linspace(0, 2*np.pi, 6, endpoint=False)+np.radians(30)

    Secondary = make_hexagonal_aperture(D_secondary)#

    def func(grid):
        res = segmented_aperture(grid)

        res *=  1 - Secondary(grid)

        for angle in spider_angles:
            x = D_tot * np.cos(angle)
            y = D_tot * np.sin(angle)

            res *= Field(make_spider((0, 0), (x, y), D_spider)(grid),grid)

        return Field(res, grid)

    return func

def make_NIRC2_incircle_pupil_mask():
    ''' Generates the NIRC2 large hexagonal mask

    source: KAON_1104_Vortex_User_Manual

    Parameters
    ----------

    Returns
    -------
    func : Field

    '''
    diameter = 8.72 # meter
    diameter_obscuration = 2.948# meter

    spider_width = 66.73E-3 # meter

    aperture = make_circular_aperture(diameter)

    secondary_obscuration = make_circular_aperture(diameter_obscuration)

    #Adding Spiders
    spiders = 1
    spider_angles = np.linspace(0, 2*np.pi, 6, endpoint=False)+np.radians(30)

    def func(grid):
        res = aperture(grid)

        res *=  1 - secondary_obscuration(grid)

        for angle in spider_angles:
            x = 10.93 * np.cos(angle)
            y = 10.93 * np.sin(angle)

            res *= Field(make_spider((0, 0), (x, y), spider_width)(grid),grid)

        return Field(res, grid)

    return func

def make_NIRC2_lyot_stop():
    '''Generates the NIRC2 Lyot stop.

    Based on '180518_NIRC2_LyotStop_V1' by JR Delorme.

    '''
    # dimensions of the mask
    # currently in pupil plane dimenstions, this is not the projected on-sky size.

    diameter_keck_aperture = 10.949 # meter

    diameter_obscuration = 2 * 0.137 * diameter_keck_aperture# meter

    spider_width = 0.020 * diameter_keck_aperture# meter
    spider_length = 0.255 * diameter_keck_aperture# meter

    hexagonal_side_length = 0.081 * diameter_keck_aperture# meter

    circular_aperture_diameter = diameter_keck_aperture

    circumdiameter_hexagon_outer = (np.sqrt(2) + 1) * hexagonal_side_length
    circumdiameter_hexagon_inner = 2 * np.cos(np.radians(30)) * hexagonal_side_length#np.sqrt(circumdiameter_hexagon_outer**2 - hexagonal_side_length**2)

    start_aperture = make_circular_aperture(circular_aperture_diameter)

    central_obscuration = make_circular_aperture(diameter_obscuration)

    # need to add this offset angle to give it the same rotation as the Keck aperture
    offset_angle = np.radians(90)

    spider_angles = np.linspace(0, 2*np.pi, 6, endpoint=False) + offset_angle

    # the offset of the segment we remove in the direction to the right.
    initial_offset = diameter_obscuration / 2 + spider_length + circumdiameter_hexagon_outer / 2

    # segments offsets that we will remove from the aperture
    offsets = [[initial_offset,0],
               [-initial_offset,0],
               [initial_offset,circumdiameter_hexagon_inner],
               [-initial_offset,circumdiameter_hexagon_inner],
               [initial_offset,-circumdiameter_hexagon_inner],
               [-initial_offset,-circumdiameter_hexagon_inner],
               [initial_offset,2*circumdiameter_hexagon_inner],
               [-initial_offset,2*circumdiameter_hexagon_inner],
               [initial_offset,-2*circumdiameter_hexagon_inner],
               [-initial_offset,-2*circumdiameter_hexagon_inner],
               [np.cos(np.radians(60))*initial_offset,np.sin(np.radians(60))*initial_offset],
               [np.cos(np.radians(60))*initial_offset+np.cos(np.radians(30))*circumdiameter_hexagon_inner,np.sin(np.radians(60))*initial_offset-np.sin(np.radians(30))*circumdiameter_hexagon_inner],
               [np.cos(np.radians(60))*initial_offset-np.cos(np.radians(30))*circumdiameter_hexagon_inner,np.sin(np.radians(60))*initial_offset+np.sin(np.radians(30))*circumdiameter_hexagon_inner],
               [np.cos(np.radians(60))*initial_offset-2*np.cos(np.radians(30))*circumdiameter_hexagon_inner,np.sin(np.radians(60))*initial_offset+2*np.sin(np.radians(30))*circumdiameter_hexagon_inner],

               [np.cos(np.radians(120))*initial_offset,np.sin(np.radians(120))*initial_offset],
               [np.cos(np.radians(120))*initial_offset+np.cos(np.radians(30))*circumdiameter_hexagon_inner,np.sin(np.radians(120))*initial_offset+np.sin(np.radians(30))*circumdiameter_hexagon_inner],
               [np.cos(np.radians(120))*initial_offset-np.cos(np.radians(30))*circumdiameter_hexagon_inner,np.sin(np.radians(120))*initial_offset-np.sin(np.radians(30))*circumdiameter_hexagon_inner],

               [np.cos(np.radians(-120))*initial_offset,np.sin(np.radians(-120))*initial_offset],
               [np.cos(np.radians(-120))*initial_offset+np.cos(np.radians(30))*circumdiameter_hexagon_inner,np.sin(np.radians(-120))*initial_offset-np.sin(np.radians(30))*circumdiameter_hexagon_inner],
               [np.cos(np.radians(-120))*initial_offset-np.cos(np.radians(30))*circumdiameter_hexagon_inner,np.sin(np.radians(-120))*initial_offset+np.sin(np.radians(30))*circumdiameter_hexagon_inner],
               [np.cos(np.radians(-120))*initial_offset+2*np.cos(np.radians(30))*circumdiameter_hexagon_inner,np.sin(np.radians(-120))*initial_offset-2*np.sin(np.radians(30))*circumdiameter_hexagon_inner],

               [np.cos(np.radians(-60))*initial_offset,np.sin(np.radians(-60))*initial_offset],
               [np.cos(np.radians(-60))*initial_offset+np.cos(np.radians(30))*circumdiameter_hexagon_inner,np.sin(np.radians(-60))*initial_offset+np.sin(np.radians(30))*circumdiameter_hexagon_inner],
               [np.cos(np.radians(-60))*initial_offset-np.cos(np.radians(30))*circumdiameter_hexagon_inner,np.sin(np.radians(-60))*initial_offset-np.sin(np.radians(30))*circumdiameter_hexagon_inner],

              ]

    def func(grid):
        res = start_aperture(grid)

        res *=  1 - central_obscuration(grid)

        for angle in spider_angles:
            x = circular_aperture_diameter * np.cos(angle)
            y = circular_aperture_diameter * np.sin(angle)

            res *= Field(make_spider((0, 0), (x, y), spider_width)(grid),grid)

        for offset in offsets:
            # updating the offset position by the rotation angle
            offset_new = [offset[0] * np.cos(offset_angle) - offset[1] * np.sin(offset_angle), offset[0] * np.sin(offset_angle) + offset[1] * np.cos(offset_angle)]

            seg = make_regular_polygon_aperture(6, circumdiameter_hexagon_outer, angle=np.radians(30) + offset_angle, center=offset_new)(grid)

            res *= 1 - seg

        return Field(res, grid)

    return func


if __name__ == '__main__':

    Nx= 1024 * 4
    pupil_grid = make_pupil_grid(Nx,10.93)

    supersampling_factor = 1

    keck_aperture = evaluate_supersampled(make_keck_aperture(with_secondary=True, with_spiders=True, return_segments=False), pupil_grid, supersampling_factor)

    NIRC2_incircle = evaluate_supersampled(make_NIRC2_incircle_pupil_mask(), pupil_grid, supersampling_factor)

    NIRC2_large_hex = evaluate_supersampled(make_NIRC2_large_hexagonal_mask(), pupil_grid, supersampling_factor)

    NIRC2_Lyot_Stop = evaluate_supersampled(make_NIRC2_lyot_stop(), pupil_grid, supersampling_factor)
    '''
    plt.figure()
    imshow_field(keck_aperture)
    plt.colorbar()

    plt.title('Keck aperture')

    plt.figure()
    imshow_field(NIRC2_incircle)
    plt.colorbar()

    plt.title('NIRC2 incircle mask, relative throughput = ' + str(np.round(np.sum(NIRC2_incircle) / np.sum(keck_aperture), 2)))

    plt.figure()
    imshow_field(NIRC2_large_hex)
    plt.colorbar()

    plt.title('NIRC2 large hexagonal mask')
    
    plt.figure()
    imshow_field(keck_aperture * NIRC2_large_hex)
    plt.colorbar()

    plt.title('Keck aperture * NIRC2 large hexagonal mask')

    plt.figure()
    imshow_field(keck_aperture * NIRC2_incircle)
    plt.colorbar()

    plt.title('Keck aperture * NIRC2 incircle mask')
    
    plt.figure()
    imshow_field(NIRC2_Lyot_Stop)
    plt.colorbar()

    plt.title('NIRC2 Lyot Stop, relative throughput = ' + str(np.round(np.sum(NIRC2_Lyot_Stop) / np.sum(keck_aperture), 2)))
'''

    test_aperture, _ = get_aperture(aperturename='keck+NIRC2_large_hexagonal_mask', pupil_grid=pupil_grid,
                                 rotation_angle_aperture=0, oversampling_factor=1, rotation_primary_deg=35)
    plt.figure()
    imshow_field(test_aperture)
    plt.colorbar()
    plt.title('keck+NIRC2_large_hexagonal_mask')
    plt.show()
